diff --git a/node_modules/@hyperlane-xyz/sdk/dist/warp/WarpCore.js b/node_modules/@hyperlane-xyz/sdk/dist/warp/WarpCore.js
index 1796e19..db4f95b 100644
--- a/node_modules/@hyperlane-xyz/sdk/dist/warp/WarpCore.js
+++ b/node_modules/@hyperlane-xyz/sdk/dist/warp/WarpCore.js
@@ -94,57 +94,91 @@ export class WarpCore {
     /**
      * Simulates a transfer to estimate 'local' gas fees on the origin chain
      */
-    async getLocalTransferFee({ originToken, destination, sender, senderPubKey, interchainFee, }) {
-        this.logger.debug(`Estimating local transfer gas to ${destination}`);
-        const originMetadata = this.multiProvider.getChainMetadata(originToken.chainName);
-        const destinationMetadata = this.multiProvider.getChainMetadata(destination);
-        // Check constant quotes first
-        const defaultQuote = this.localFeeConstants.find((q) => q.origin === originMetadata.name &&
-            q.destination === destinationMetadata.name);
-        if (defaultQuote) {
-            return { gasUnits: 0, gasPrice: 0, fee: Number(defaultQuote.amount) };
-        }
-        // Form transactions to estimate local gas with
-        const recipient = convertToProtocolAddress(sender, destinationMetadata.protocol, destinationMetadata.bech32Prefix);
-        const txs = await this.getTransferRemoteTxs({
-            originTokenAmount: originToken.amount(1),
-            destination,
-            sender,
-            recipient,
-            interchainFee,
-        });
-        // Typically the transfers require a single transaction
-        if (txs.length === 1) {
-            try {
-                return this.multiProvider.estimateTransactionFee({
-                    chainNameOrId: originMetadata.name,
-                    transaction: txs[0],
-                    sender,
-                    senderPubKey,
-                });
-            }
-            catch (error) {
-                this.logger.error(`Failed to estimate local gas fee for ${originToken.symbol} transfer`, error);
-                throw new Error('Gas estimation failed, balance may be insufficient', {
-                    cause: error,
-                });
-            }
-        }
-        // On ethereum, sometimes 2 txs are required (one approve, one transferRemote)
-        else if (txs.length === 2 &&
-            originToken.protocol === ProtocolType.Ethereum) {
-            const provider = this.multiProvider.getEthersV5Provider(originMetadata.name);
-            // We use a hard-coded const as an estimate for the transferRemote because we
-            // cannot reliably simulate the tx when an approval tx is required first
-            return estimateTransactionFeeEthersV5ForGasUnits({
+    async getLocalTransferFee({ originToken, destination, sender, senderPubKey, interchainFee }) {
+      console.log('Starting getLocalTransferFee function');
+      console.log('Params:', { originToken, destination, sender, senderPubKey, interchainFee });
+  
+      this.logger.debug(`Estimating local transfer gas to ${destination}`);
+      
+      const originMetadata = this.multiProvider.getChainMetadata(originToken.chainName);
+      console.log('Origin metadata:', originMetadata);
+  
+      const destinationMetadata = this.multiProvider.getChainMetadata(destination);
+      console.log('Destination metadata:', destinationMetadata);
+  
+      console.log('Checking for default quote in localFeeConstants');
+      const defaultQuote = this.localFeeConstants.find((q) => 
+          q.origin === originMetadata.name && q.destination === destinationMetadata.name
+      );
+      console.log('Default quote found:', defaultQuote);
+  
+      if (defaultQuote) {
+          console.log('Returning default quote');
+          return { gasUnits: 0, gasPrice: 0, fee: Number(defaultQuote.amount) };
+      }
+  
+      console.log('No default quote found, proceeding with transaction estimation');
+  
+      console.log('Converting sender address to protocol address');
+      const recipient = convertToProtocolAddress(sender, destinationMetadata.protocol, destinationMetadata.bech32Prefix);
+      console.log('Converted recipient address:', recipient);
+  
+      console.log('Getting transfer remote transactions');
+      const txs = await this.getTransferRemoteTxs({
+          originTokenAmount: originToken.amount(1),
+          destination,
+          sender,
+          recipient,
+          interchainFee,
+      });
+      console.log('Number of transactions:', txs.length);
+      console.log('Transactions:', txs);
+  
+      if (txs.length === 1) {
+          console.log('Single transaction, estimating fee');
+          try {
+              const fee = await this.multiProvider.estimateTransactionFee({
+                  chainNameOrId: originMetadata.name,
+                  transaction: txs[0],
+                  sender,
+                  senderPubKey,
+              });
+              console.log('Estimated fee:', fee);
+              return fee;
+          } catch (error) {
+              console.error('Error estimating fee:', error);
+              this.logger.error(`Failed to estimate local gas fee for ${originToken.symbol} transfer`, error);
+              
+              // Fallback to static gas value
+              const staticGasUnits = BigInt(0x1a2d6) * 2n; // Multiply by 2 for safety
+              console.log('Using fallback static gas value:', staticGasUnits.toString());
+              
+              const provider = this.multiProvider.getEthersV5Provider(originMetadata.name);
+              console.log('Ethers provider:', provider);
+
+              const fallbackFee = await estimateTransactionFeeEthersV5ForGasUnits({
                 provider,
-                gasUnits: EVM_TRANSFER_REMOTE_GAS_ESTIMATE,
+                gasUnits: staticGasUnits,
             });
-        }
-        else {
-            throw new Error('Cannot estimate local gas for multiple transactions');
-        }
-    }
+              
+              console.log('Fallback fee:', fallbackFee);
+              return fallbackFee;
+          }
+      } else if (txs.length === 2 && originToken.protocol === ProtocolType.Ethereum) {
+          console.log('Two transactions for Ethereum, using hard-coded estimate');
+          const provider = this.multiProvider.getEthersV5Provider(originMetadata.name);
+          console.log('Ethers provider:', provider);
+          const fee = await estimateTransactionFeeEthersV5ForGasUnits({
+              provider,
+              gasUnits: EVM_TRANSFER_REMOTE_GAS_ESTIMATE,
+          });
+          console.log('Estimated fee using hard-coded gas units:', fee);
+          return fee;
+      } else {
+          console.error('Unexpected number of transactions:', txs.length);
+          throw new Error('Cannot estimate local gas for multiple transactions');
+      }
+  }
     /**
      * Similar to getLocalTransferFee in that it estimates local gas fees
      * but it also resolves the native token and returns a TokenAmount
@@ -399,6 +433,7 @@ export class WarpCore {
             originToken,
             destination,
         });
+        console.log('Interchain quote:', interchainQuote);
         // Get balance of the IGP fee token, which may be different from the transfer token
         const interchainQuoteTokenBalance = originToken.isFungibleWith(interchainQuote.token)
             ? senderBalanceAmount
